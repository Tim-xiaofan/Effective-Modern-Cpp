Chapter 1. Deducing Types/Item 1-- Understand template type deduction/case1
Chapter 1. Deducing Types/Item 1-- Understand template type deduction/func_param
Chapter 1. Deducing Types/Item 1-- Understand template type deduction/case2
Chapter 1. Deducing Types/Item 1-- Understand template type deduction/array_param
Chapter 1. Deducing Types/Item 1-- Understand template type deduction/case3
Chapter 1. Deducing Types/Item 3--Understand decltype/universal
Chapter 1. Deducing Types/Item 3--Understand decltype/template_ret
Chapter 1. Deducing Types/Item 3--Understand decltype/var_decltype
Chapter 1. Deducing Types/Item 2--Understand auto type deduction/auto
Chapter 1. Deducing Types/Item 4--Know how to view deduced types/runtime
Chapter 2. auto/Item 5 Prefer auto to explicit type declarations/item5
Chapter 2. auto/Item 6 Use the explicitly typed initializer idiom when auto deduces undesired types/item6
Chapter 3. Moving to Modern C++/Item 7 Distinguish between () and {} when creating objects/item6
Chapter 3. Moving to Modern C++/Item 9 Prefer alias declarations to typedefs/item9
Chapter 3. Moving to Modern C++/Item 10 Prefer scoped enums to unscoped enums/item10
Chapter 3. Moving to Modern C++/Item 8 Prefer nullptr to 0 and NULL/item8
Chapter 3. Moving to Modern C++/Item 11 Prefer deleted functions to private undefined ones/item11
Chapter 3. Moving to Modern C++/Item 12 Declare overriding functions override/item12
Chapter 3. Moving to Modern C++/Item 13 Prefer const_iterators to iterators/item13
Chapter 3. Moving to Modern C++/Item 14 Declare functions noexcept if they wonâ€™t emit exceptions/item14
Chapter 3. Moving to Modern C++/Item 15 Use constexpr whenever possible/item15
Chapter 3. Moving to Modern C++/Item 09 Prefer alias declarations to typedefs/item9
Chapter 3. Moving to Modern C++/Item 16 Make const member functions thread safe/item16
Chapter 3. Moving to Modern C++/Item 07 Distinguish between () and {} when creating objects/item6
Chapter 3. Moving to Modern C++/Item 08 Prefer nullptr to 0 and NULL/item8
Chapter 3. Moving to Modern C++/Item 17 Understand special member function generation/item17
Chapter 4. Smart Pointers/Item 18 Use unique_ptr for exclusive-ownership resource management/item18
Chapter 4. Smart Pointers/Item 19 Use shared_ptr for shared-ownership resource management/item19
Chapter 4. Smart Pointers/Item 20 Use weak_ptr for shared_ptr-like pointers that can dangle/item20
Chapter 4. Smart Pointers/Item 21 Prefer make_unique and make_shared to direct use of new/item21
Chapter 4. Smart Pointers/Item 22 When using the Pimpl Idiom, define special member functions in the implementation file/item22
Chapter 5. Rvalue References, Move Semantics,and Perfect Forwarding/Item 23 Understand move and forward/item23
Chapter 5. Rvalue References, Move Semantics,and Perfect Forwarding/Item 24 Distinguish universal references from rvalue references/item24
Chapter 5. Rvalue References, Move Semantics,and Perfect Forwarding/Item 25 Use move on rvalue references,forward on universal references/item25
Chapter 5. Rvalue References, Move Semantics,and Perfect Forwarding/Item 26 Avoid overloading on universal references/item26
Chapter 5. Rvalue References, Move Semantics,and Perfect Forwarding/Item 27 Familiarize yourself with alternatives to overloading on universal references/item27
Chapter 5. Rvalue References, Move Semantics,and Perfect Forwarding/Item 28 Understand reference collapsing/item28
Chapter 5. Rvalue References, Move Semantics,and Perfect Forwarding/Item 29 Assume that move operations are not present,not cheap, and not used/item29
Chapter 5. Rvalue References, Move Semantics,and Perfect Forwarding/Item 30 Familiarize yourself with perfect forwarding failure cases/item30
Chapter 6. Lambda Expressions/Item 31 Avoid default capture modes/item31
Chapter 6. Lambda Expressions/Item 32 Use init capture to move objects into closures/item32
Chapter 6. Lambda Expressions/Item 33 Use decltype on auto&& parameters to forward them/item31
Chapter 6. Lambda Expressions/Item 33 Use decltype on auto&& parameters to forward them/item33
Chapter 6. Lambda Expressions/Item 34 Prefer lambdas to bind/item34
Chapter 7. The Concurrency API/Item 35 Prefer task-based programming to thread based/item35
Chapter 7. The Concurrency API/Item 36 Specify async if asynchronicity is essential/item36
Chapter 7. The Concurrency API/Item 37 Make threads unjoinable on all paths/item37
Chapter 7. The Concurrency API/Item 38
Chapter 7. The Concurrency API/Item 38 Be aware of varying thread handle destructor behavior/item38
